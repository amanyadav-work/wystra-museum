const scene = new THREE.Scene, camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, .1, 1e3); camera.position.set(-10, 100, 10); const renderer = new THREE.WebGLRenderer({ antialias: !0, alpha: !0 }); renderer.setSize(window.innerWidth, window.innerHeight), renderer.shadowMap.enabled = !0, renderer.shadowMap.type = THREE.PCFSoftShadowMap, document.getElementById("canvasContainer").appendChild(renderer.domElement); const controls = new THREE.OrbitControls(camera, renderer.domElement); controls.enableDamping = !0, controls.dampingFactor = .25, controls.screenSpacePanning = !1, controls.minDistance = 1, controls.maxDistance = 500, controls.maxPolarAngle = Math.PI / 2; const ambientLight = new THREE.AmbientLight(4210752, 1); scene.add(ambientLight); const directionalLight = new THREE.DirectionalLight(16777215, 1); directionalLight.position.set(100, 80, 100), scene.add(directionalLight); const pointLight = new THREE.PointLight(10597830, 4.8, 100); pointLight.castShadow = !1, scene.add(pointLight); const groundGeometry = new THREE.PlaneGeometry(500, 500), groundMaterial = new THREE.ShadowMaterial({ opacity: .2 }), groundPlane = new THREE.Mesh(groundGeometry, groundMaterial); function applySmoothMaterial(e) { e.traverse((function (e) { if (e.isMesh) { const n = new THREE.MeshStandardMaterial({ color: e.material.color || 16777215, map: e.material.map, roughness: .5, metalness: .5 }); e.material = n, e.castShadow = !0, e.receiveShadow = !0 } })) } groundPlane.rotation.x = -Math.PI / 2, groundPlane.position.y = -.01, groundPlane.receiveShadow = !0, scene.add(groundPlane);

const dLoader = new THREE.DRACOLoader();
dLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.7/');

const gltfLoader = new THREE.GLTFLoader();
gltfLoader.setDRACOLoader(dLoader);

let model, isHoveringModel = !1; const defaultModelPath = "Models/Knight%20Statue2.glb"; function fitModelToScreen(e) { const n = (new THREE.Box3).setFromObject(e), o = n.getSize(new THREE.Vector3), t = n.getCenter(new THREE.Vector3), a = Math.max(o.x, o.y, o.z), r = camera.fov * (Math.PI / 180); Math.abs(a / (2 * Math.tan(r / 2))); camera.position.set(t.x, t.y + 2.2, t.z + 1), camera.lookAt(t), controls.target.set(t.x, t.y, t.z), controls.update() } gltfLoader.load(defaultModelPath, (e => { model = e.scene, applySmoothMaterial(model), scene.add(model), fitModelToScreen(model) }), void 0, (e => { console.error("Error loading model:", e) })); const raycaster = new THREE.Raycaster, mouse = new THREE.Vector2, lightTarget = new THREE.Vector3; function animate() { if (requestAnimationFrame(animate), controls.update(), isHoveringModel) pointLight.position.lerp(lightTarget, .1); else { const e = new THREE.Vector3(10 * (2 * mouse.x - 1), 10 * -(2 * mouse.y - 1) + 5, 10); pointLight.position.lerp(e, .1) } renderer.render(scene, camera) } window.addEventListener("mousemove", (e => { if (mouse.x = e.clientX / window.innerWidth * 2 - 1, mouse.y = -e.clientY / window.innerHeight * 2 + 1, raycaster.setFromCamera(mouse, camera), model) { const e = raycaster.intersectObject(model, !0); if (e.length > 0) { const n = e[0].point, o = 1, t = e[0].face.normal.clone().normalize(); lightTarget.copy(n).add(t.multiplyScalar(o)), isHoveringModel = !0 } else isHoveringModel = !1 } })), controls.enableZoom = !1, controls.enableRotate = !1, controls.enablePan = !1, window.addEventListener("resize", (() => { const e = window.innerWidth, n = window.innerHeight; renderer.setSize(e, n), camera.aspect = e / n, camera.updateProjectionMatrix() })), animate(); const scene2 = new THREE.Scene, camera2 = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, .1, 1e3); camera2.position.set(10, 50, 20); const renderer2 = new THREE.WebGLRenderer({ antialias: !0, alpha: !0 }); renderer2.setSize(window.innerWidth, window.innerHeight), renderer2.shadowMap.enabled = !0, renderer2.shadowMap.type = THREE.PCFSoftShadowMap, document.getElementById("canvasContainer2").appendChild(renderer2.domElement); const controls2 = new THREE.OrbitControls(camera2, renderer2.domElement); controls2.enableDamping = !0, controls2.dampingFactor = .25, controls2.screenSpacePanning = !1, controls2.minDistance = 1, controls2.maxDistance = 500, controls2.maxPolarAngle = Math.PI / 2; const ambientLight2 = new THREE.AmbientLight(4210752, 1); scene2.add(ambientLight2); const directionalLight2 = new THREE.DirectionalLight(16777215, 1); directionalLight2.position.set(100, 80, 100), scene2.add(directionalLight2); const pointLight2 = new THREE.PointLight(10597830, 4.8, 100); pointLight2.castShadow = !1, scene2.add(pointLight2); const groundGeometry2 = new THREE.PlaneGeometry(500, 500), groundMaterial2 = new THREE.ShadowMaterial({ opacity: .2 }), groundPlane2 = new THREE.Mesh(groundGeometry2, groundMaterial2); function applySmoothMaterial2(e) { e.traverse((function (e) { if (e.isMesh) { const n = new THREE.MeshStandardMaterial({ color: e.material.color || 16777215, map: e.material.map, roughness: .5, metalness: .5 }); e.material = n, e.castShadow = !0, e.receiveShadow = !0 } })) } groundPlane2.rotation.x = -Math.PI / 2, groundPlane2.position.y = -.01, groundPlane2.receiveShadow = !0, scene2.add(groundPlane2); const gltfLoader2 = new THREE.GLTFLoader; let model2, isHoveringModel2 = !1; function fitModelToScreen2(e) { const n = (new THREE.Box3).setFromObject(e), o = n.getSize(new THREE.Vector3), t = n.getCenter(new THREE.Vector3), a = Math.max(o.x, o.y, o.z), r = camera2.fov * (Math.PI / 180); Math.abs(a / (2 * Math.tan(r / 2))); camera2.position.set(-.1, t.y + 1.12, .5), camera2.lookAt(t), controls2.target.set(t.x - .5, t.y + .78, t.z), controls2.update() } gltfLoader2.load("Models/Wizard%20Statue.glb", (e => { model2 = e.scene, applySmoothMaterial2(model2), scene2.add(model2), fitModelToScreen2(model2) }), void 0, (e => { console.error("Error loading model:", e) })); const raycaster2 = new THREE.Raycaster, mouse2 = new THREE.Vector2, lightTarget2 = new THREE.Vector3; function animate2() { if (requestAnimationFrame(animate2), controls2.update(), isHoveringModel2) pointLight2.position.lerp(lightTarget2, .1); else { const e = new THREE.Vector3(10 * (2 * mouse2.x - 1), 10 * -(2 * mouse2.y - 1) + 5, 10); pointLight2.position.lerp(e, .1) } renderer2.render(scene2, camera2) } window.addEventListener("mousemove", (e => { if (mouse2.x = e.clientX / window.innerWidth * 2 - 1, mouse2.y = -e.clientY / window.innerHeight * 2 + 1, raycaster2.setFromCamera(mouse2, camera2), model2) { const e = raycaster2.intersectObject(model2, !0); if (e.length > 0) { const n = e[0].point, o = 1, t = e[0].face.normal.clone().normalize(); lightTarget2.copy(n).add(t.multiplyScalar(o)), isHoveringModel2 = !0 } else isHoveringModel2 = !1 } })), controls2.enableZoom = !1, controls2.enableRotate = !1, controls2.enablePan = !1, window.addEventListener("resize", (() => { const e = window.innerWidth, n = window.innerHeight; renderer2.setSize(e, n), camera2.aspect = e / n, camera2.updateProjectionMatrix() })), animate2(); const scene3 = new THREE.Scene, camera3 = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, .1, 1e3), renderer3 = new THREE.WebGLRenderer({ antialias: !0, alpha: !0 }); renderer3.setSize(window.innerWidth, window.innerHeight), renderer3.shadowMap.enabled = !0, renderer3.shadowMap.type = THREE.PCFSoftShadowMap, document.getElementById("canvasContainer3").appendChild(renderer3.domElement); const controls3 = new THREE.OrbitControls(camera3, renderer3.domElement); controls3.enableDamping = !0, controls3.dampingFactor = .25, controls3.screenSpacePanning = !1, controls3.minDistance = 1, controls3.maxDistance = 500, controls3.maxPolarAngle = Math.PI / 2; const ambientLight3 = new THREE.AmbientLight(4210752, 1); scene3.add(ambientLight3); const directionalLight3 = new THREE.DirectionalLight(10597830, 1); directionalLight3.position.set(100, 80, 100), scene3.add(directionalLight3); const pointLight3 = new THREE.PointLight(7445438, 4.8, 100); pointLight3.castShadow = !1, scene3.add(pointLight3); const groundGeometry3 = new THREE.PlaneGeometry(500, 500), groundMaterial3 = new THREE.ShadowMaterial({ opacity: .2 }), groundPlane3 = new THREE.Mesh(groundGeometry3, groundMaterial3); function applySmoothMaterial3(e) { e.traverse((function (e) { if (e.isMesh) { const n = new THREE.MeshStandardMaterial({ color: e.material.color || 16777215, map: e.material.map, roughness: .5, metalness: .5 }); e.material = n, e.castShadow = !0, e.receiveShadow = !0 } })) } groundPlane3.rotation.x = -Math.PI / 2, groundPlane3.position.y = -.01, groundPlane3.receiveShadow = !0, scene3.add(groundPlane3);

const dLoader3 = new THREE.DRACOLoader();
dLoader3.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.7/');

const gltfLoader3 = new THREE.GLTFLoader();
gltfLoader3.setDRACOLoader(dLoader3);

let model3, isHoveringModel3 = !1; function fitModelToScreen3(e) { const n = (new THREE.Box3).setFromObject(e), o = n.getSize(new THREE.Vector3), t = n.getCenter(new THREE.Vector3), a = Math.max(o.x, o.y, o.z), r = camera3.fov * (Math.PI / 180); Math.abs(a / (2 * Math.tan(r / 2))); camera3.position.set(t.x + 1, t.y + 1.5, t.z + 1.4), camera3.lookAt(t), controls3.target.set(t.x - 1.8, t.y + .9, t.z), controls3.update() } gltfLoader3.load("Models/Knight%20Statue2.glb", (e => { model3 = e.scene, applySmoothMaterial3(model3), scene3.add(model3), fitModelToScreen3(model3) }), void 0, (e => { console.error("Error loading model:", e) })); const raycaster3 = new THREE.Raycaster, mouse3 = new THREE.Vector2, lightTarget3 = new THREE.Vector3; function animate3() { if (requestAnimationFrame(animate3), controls3.update(), isHoveringModel3) pointLight3.position.lerp(lightTarget3, .1); else { const e = new THREE.Vector3(10 * (2 * mouse3.x - 1), 10 * -(2 * mouse3.y - 1) + 5, 10); pointLight3.position.lerp(e, .1) } renderer3.render(scene3, camera3) } window.addEventListener("mousemove", (e => { if (mouse3.x = e.clientX / window.innerWidth * 2 - 1, mouse3.y = -e.clientY / window.innerHeight * 2 + 1, raycaster3.setFromCamera(mouse3, camera3), model3) { const e = raycaster3.intersectObject(model3, !0); if (e.length > 0) { const n = e[0].point, o = 1, t = e[0].face.normal.clone().normalize(); lightTarget3.copy(n).add(t.multiplyScalar(o)), isHoveringModel3 = !0 } else isHoveringModel3 = !1 } })), controls3.enableZoom = !1, controls3.enableRotate = !1, controls3.enablePan = !1, window.addEventListener("resize", (() => { const e = window.innerWidth, n = window.innerHeight; renderer3.setSize(e, n), camera3.aspect = e / n, camera3.updateProjectionMatrix() })), animate3(); const scene4 = new THREE.Scene, camera4 = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, .1, 1e3), renderer4 = new THREE.WebGLRenderer({ antialias: !0, alpha: !0 }); renderer4.setSize(window.innerWidth, window.innerHeight), renderer4.shadowMap.enabled = !0, renderer4.shadowMap.type = THREE.PCFSoftShadowMap, document.getElementById("canvasContainer4").appendChild(renderer4.domElement); const controls4 = new THREE.OrbitControls(camera4, renderer4.domElement); controls4.enableDamping = !0, controls4.dampingFactor = .25, controls4.screenSpacePanning = !1, controls4.minDistance = 1, controls4.maxDistance = 500, controls4.maxPolarAngle = Math.PI / 2; const ambientLight4 = new THREE.AmbientLight(4210752, 1); scene4.add(ambientLight4); const directionalLight4 = new THREE.DirectionalLight(16777215, 1); directionalLight4.position.set(100, 80, 100), scene4.add(directionalLight4); const pointLight4 = new THREE.PointLight(10597830, 4.8, 100); pointLight4.castShadow = !1, scene4.add(pointLight4); const groundGeometry4 = new THREE.PlaneGeometry(500, 500), groundMaterial4 = new THREE.ShadowMaterial({ opacity: .2 }), groundPlane4 = new THREE.Mesh(groundGeometry4, groundMaterial4); function applySmoothMaterial4(e) { e.traverse((function (e) { if (e.isMesh) { const n = new THREE.MeshStandardMaterial({ color: e.material.color || 16777215, map: e.material.map, roughness: .5, metalness: .5 }); e.material = n, e.castShadow = !0, e.receiveShadow = !0 } })) } groundPlane4.rotation.x = -Math.PI / 2, groundPlane4.position.y = -.01, groundPlane4.receiveShadow = !0, scene4.add(groundPlane4); const gltfLoader4 = new THREE.GLTFLoader; let model4, isHoveringModel4 = !1; function fitModelToScreen4(e) { const n = (new THREE.Box3).setFromObject(e), o = n.getSize(new THREE.Vector3), t = n.getCenter(new THREE.Vector3), a = Math.max(o.x, o.y, o.z), r = camera4.fov * (Math.PI / 180); Math.abs(a / (2 * Math.tan(r / 2))); camera4.position.set(t.x - .4, t.y + .8, t.z + .3), camera4.lookAt(t), controls4.target.set(t.x - .6, t.y + .78, t.z + .3), controls4.update() } gltfLoader4.load("Models/Avalon%20Champion%20Statue.glb", (e => { model4 = e.scene, applySmoothMaterial4(model4), scene4.add(model4), fitModelToScreen4(model4) }), void 0, (e => { console.error("Error loading model:", e) })); const raycaster4 = new THREE.Raycaster, mouse4 = new THREE.Vector2, lightTarget4 = new THREE.Vector3; function animate4() { if (requestAnimationFrame(animate4), controls4.update(), isHoveringModel4) pointLight4.position.lerp(lightTarget4, .1); else { const e = new THREE.Vector3(10 * (2 * mouse4.x - 1), 10 * -(2 * mouse4.y - 1) + 5, 10); pointLight4.position.lerp(e, .1) } renderer4.render(scene4, camera4) } window.addEventListener("mousemove", (e => { if (mouse4.x = e.clientX / window.innerWidth * 2 - 1, mouse4.y = -e.clientY / window.innerHeight * 2 + 1, raycaster4.setFromCamera(mouse4, camera4), model4) { const e = raycaster4.intersectObject(model4, !0); if (e.length > 0) { const n = e[0].point, o = 1, t = e[0].face.normal.clone().normalize(); lightTarget4.copy(n).add(t.multiplyScalar(o)), isHoveringModel4 = !0 } else isHoveringModel4 = !1 } })), controls4.enableZoom = !1, controls4.enableRotate = !1, controls4.enablePan = !1, window.addEventListener("resize", (() => { const e = window.innerWidth, n = window.innerHeight; renderer4.setSize(e, n), camera4.aspect = e / n, camera4.updateProjectionMatrix() })), animate4();